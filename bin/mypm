#!/usr/bin/env python
import os
import re
import webbrowser
from dataclasses import dataclass
from typing import Any

import mytools as t
from mytools import log


@dataclass
class Package:
    repo: str
    file: str | re.Pattern[str]
    prerelease: bool = False


@dataclass
class Release:
    version: str
    changelog: str
    url: str


PACKAGES = {
    "v2rayn": Package(
        "2dust/v2rayN",
        "v2rayN-linux-64.deb",
    ),
    "musicfree": Package(
        "maotoumao/MusicFreeDesktop",
        re.compile(r"linux-amd64\.deb$"),
    ),
    "lmms": Package(
        "LMMS/lmms",
        re.compile(r"linux-x86_64\.AppImage$"),
        True,
    ),  # dep: libfuse2t64
}


def fetch_release(pkg: Package):
    url_prefix = f"https://api.github.com/repos/{pkg.repo}/releases"
    data: dict[str, Any] = (
        t.fetch(url_prefix + "?per_page=1")[0]
        if pkg.prerelease
        else t.fetch(url_prefix + "/latest")
    )

    for asset in filter(
        (lambda x: x["name"] == pkg.file)
        if isinstance(pkg.file, str)
        else (lambda x: pkg.file.search(x["name"])),  # type: ignore
        data["assets"],
    ):
        return Release(
            data["tag_name"].lower().lstrip("v"),
            data["body"],
            "https://gh-proxy.com/" + asset["browser_download_url"],
        )

    webbrowser.open(f"https://github.com/{pkg.repo}/releases")
    raise ValueError(f"{pkg.file} not found")


with t.cli(description="my package manager") as arg:

    @arg("-l", action="store_true", help="show packages")
    def list(val: object):
        if val is True:
            print("\n".join(PACKAGES.keys()))

    @arg("-i")
    def install(package_name: str):
        pkg = PACKAGES[package_name]
        current_version = (
            t.cmd(
                f"dpkg -l | grep '^ii  {package_name}' | awk '{{print $3}}'", "capture"
            )
            .strip()
            .lower()
        )
        rls = fetch_release(pkg)
        if current_version == rls.version:
            log.info(f"{package_name} is already up to date ({current_version})")
            return

        # download
        log.info("changelog: " + "\n".join(rls.changelog.splitlines()[:20]))
        if not t.confirm(f"install {package_name} {current_version} -> {rls.version}"):
            return
        tmp_filepath = t.TMPPATH / (f"{package_name}-{rls.version}")
        t.cmd(f"wget -O '{tmp_filepath}' '{rls.url}'")

        # check relative process

        # install
        _, extname = os.path.splitext(rls.url)
        if extname == ".deb":
            tmp_filepath.rename(f"{tmp_filepath}.deb")
            t.cmd(f"sudo apt remove -y {package_name}")
            t.cmd(f"sudo apt install -y {tmp_filepath}")
            tmp_filepath.unlink()
        elif extname == ".AppImage":
            target_filepath = t.BINPATH / package_name
            tmp_filepath.replace(target_filepath)
            target_filepath.chmod(target_filepath.stat().st_mode | 0o111)

            # create desktop file
            desktop_filepath = t.BINPATH / (
                f"../share/applications/{package_name}.desktop"
            )
            if desktop_filepath.exists():
                log.info(f"find desktop file: {desktop_filepath}, skipping creation")
                return
            log.info(f"creating {desktop_filepath}")
            desktop_filepath.write_text(f"""[Desktop Entry]
Exec={target_filepath}
Name={package_name}
Comment={input("Comment: ")}
Type=Application
Terminal=false
Icon={input("Icon: ")}
""")

    @arg("-d")
    def delete(package_name: str):
        raise NotImplementedError()
