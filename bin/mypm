#!/usr/bin/env python
import os
import re
import shutil
import tempfile
from abc import ABC, abstractmethod
from functools import cache
from pathlib import Path
from typing import override

import mytools as t
from mytools import log


# package
class Package(ABC):
    @property
    def bin(self):
        return self.__class__.__name__

    @abstractmethod
    def latest(self) -> str | None: ...
    def confirm(self, version: str, changelog: str, download_url: str) -> str | None:
        if self.version == version:
            log.info(f"Already up to date: {version}")
            return
        log.info("Changelog:\n" + "\n".join(changelog.splitlines()[:20]))
        if not t.confirm(f"Update: {self.version} -> {version}"):
            return
        return download_url

    def download(self, url: str):
        filename = url.rsplit("/", 1)[-1]
        temp = tempfile.NamedTemporaryFile(
            prefix=self.bin,
            suffix=filename,
            delete=False,
        )
        t.cmd(f"wget -O '{temp.name}' '{url}'")
        return temp

    @property
    @cache
    def version(self) -> str: ...
    @abstractmethod
    def install(self, filepath: str): ...
    @abstractmethod
    def uninstall(self): ...


## source
class GitHub(Package, ABC):
    repo: str
    file: str | re.Pattern[str]
    prerelease = False

    @property
    @cache
    def api_url(self):
        prefix = os.getenv("GITHUB", "")
        if prefix:
            log.info("Get GITHUB=" + prefix)
        return f"{prefix}https://api.github.com/repos/{self.repo}/releases"

    @override
    def latest(self):
        data = F.get(
            self.api_url + ("?per_page=1" if self.prerelease else "/latest")
        ).json()
        file = self.file

        try:
            data = data[0] if self.prerelease else data
            for asset in filter(
                (lambda x: x["name"] == file)
                if isinstance(file, str)
                else (lambda x: file.search(x["name"])),
                data["assets"],
            ):
                return super().confirm(
                    data["tag_name"].lower().lstrip("v"),
                    data["body"],
                    asset["browser_download_url"],
                )
        except KeyError as e:
            raise ValueError(data) from e

        log.error(f"not found {self.file} on https://github.com/{self.repo}/releases")


## installer
class APT(Package, ABC):
    @property
    @cache
    def version(self):
        return (
            t.cmd(f"dpkg -l | grep '^ii  {self.bin}' | awk '{{print $3}}'", "capture")
            .strip()
            .lower()
        )

    @override
    def install(self, filepath: str):
        t.cmd(f"sudo apt install -y {filepath}")

    @override
    def uninstall(self):
        t.cmd(f"sudo apt remove -y {self.bin}")


class BIN(Package, ABC):
    @property
    @cache
    def binpath(self):
        return t.BINPATH / self.bin

    @property
    @cache
    def version(self) -> str:
        return shutil.which(self.bin) or ""

    @override
    def install(self, filepath: str):
        log.info(f"move {filepath} to {self.binpath}")
        _ = shutil.copyfile(filepath, self.binpath)
        self.binpath.chmod(self.binpath.stat().st_mode | 0o111)

        # create desktop file
        desktop_filepath = t.BINPATH.parent / f"share/applications/{self.bin}.desktop"
        if not t.confirm(f"Create {desktop_filepath}"):
            return
        if desktop_filepath.exists():
            log.info(f"Find desktop file: {desktop_filepath}, skipping creation")
            return
        _ = desktop_filepath.write_text(f"""[Desktop Entry]
Exec={self.binpath}
Name={self.bin}
Comment={input("Comment: ")}
Type=Application
Terminal=false
""")

    @override
    def uninstall(self):
        self.binpath.unlink()


## app
class v2rayn(GitHub, APT):
    repo = "2dust/v2rayN"
    file = "v2rayN-linux-64.deb"


class musicfree(GitHub, APT):
    repo = "maotoumao/MusicFreeDesktop"
    file = re.compile(r"linux-amd64\.deb$")


class lmms(GitHub, BIN):
    """deps: libfuse2t64"""

    repo = "LMMS/lmms"
    file = re.compile(r"linux-x86_64\.AppImage$")
    prerelease = True

    @property
    @cache
    def version(self):
        return (
            super().version
            and t.cmd(
                rf"{self.bin} -v | grep -oP 'LMMS \K\d+\.\d+\.\d+-\w+\.\d+'", "capture"
            ).strip()
        )


class harper_ls(GitHub, BIN):
    repo = "Automattic/harper"
    file = "harper-ls-x86_64-unknown-linux-gnu.tar.gz"

    @property
    @cache
    def bin(self):
        return super().bin.replace("_", "-")

    @property
    @cache
    def version(self):
        return (
            super().version
            and t.cmd(f"{self.bin} --version | awk '{{print $2}}'", "capture").strip()
        )

    @override
    def install(self, filepath: str):
        tmpdir = tempfile.TemporaryDirectory(prefix=self.bin, delete=False)
        t.cmd(f"tar -xf {filepath} -C {tmpdir.name}")
        super().install(f"{tmpdir.name}/{self.bin}")
        tmpdir.cleanup()


class zotero(Package):
    libpath = "/opt/zotero"

    @override
    def latest(self):
        html = F.get("https://www.zotero.org/download/").text
        match = re.search(r"Zotero (\d)", html)
        return super().confirm(
            "unknown" if match is None else match.group(1),
            "https://www.zotero.org/blog/",
            "https://www.zotero.org/download/client/dl?channel=release&platform=linux-x86_64",
        )

    @override
    def install(self, filepath: str):
        libpath = Path(self.libpath)
        if libpath.exists():
            self.uninstall()
        t.cmd(f"sudo mkdir -p {libpath}")

        t.cmd(f'sudo tar -xf "{filepath}" --strip-components=1 -C {libpath}')
        t.cmd(f"sudo {libpath / 'set_launcher_icon'}")
        (t.BINPATH.parent / f"share/applications/{self.bin}.desktop").symlink_to(
            libpath / "zotero.desktop"
        )

    @override
    def uninstall(self):
        log.info(f"rm {self.libpath}")
        t.cmd(f"sudo rm -rf {self.libpath}")


# global
PACKAGES = {p.__name__: p for p in (v2rayn, musicfree, lmms, harper_ls, zotero)}
F = t.Client()


@t.cli("my package manager")
class opts:
    list: bool = t.arg("-l", help="show packages")
    install: str = t.arg("-i")
    uninstall: str = t.arg("-d")


def main():
    if opts.list:
        print("\n".join(PACKAGES.keys()))
        return
    if opts.install:
        pkg = PACKAGES[opts.install]()
        url = pkg.latest()
        if url is not None:
            tmpfile = pkg.download(url)
            pkg.install(tmpfile.name)
            import os

            os.remove(tmpfile.name)

    if opts.uninstall:
        pkg = PACKAGES[opts.uninstall]()
        pkg.uninstall()


main()
